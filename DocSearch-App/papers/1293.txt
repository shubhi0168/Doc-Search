CS 

 Data structures  

Despite the existence and popularity of many new and classical computer languages, the evolutionary algorithm community has mostly exploited a few popular ones, avoiding them, especially if they are not compiled, under the asumption that compiled languages are always faster than interpreted languages. Wide-ranging performance analyses of implementation of evolutionary algorithms are usually focused on algorithmic implementation details and data structures, but these are usually limited to specific languages. In this paper we measure the execution speed of three common operations in genetic algorithms in many popular and emerging computer languages using different data structures and implementation alternatives, with several objectives: create a ranking for these operations, compare relative speeds taking into account different chromosome sizes and data structures, and dispel or show evidence for several hypotheses that underlie most popular evolutionary algorithm libraries and applications. We find that there is indeed basis to consider compiled languages, such as Java, faster in a general sense, but there are other languages, including interpreted ones, that can hold its ground against them.